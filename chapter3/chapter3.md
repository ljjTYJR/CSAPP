# 简介

本文档主要记录阅读CSAPP书籍第三章《程序的机器级表示》的读书笔记。第一部分内容是随书笔记，可能是随着阅读随手记下的感想，第二部分是对本章的总结，更加系统和有逻辑的内容。

## 随笔
机器码->汇编->C语言、java、python

高级语言可以描述为低级语言的“抽象”与“封装”，可能会损失一定的性能，但越来越接近于人类的思考方式（伪代码）的形式。

> 精通细节是理解更深和更基本概念的先决条件——p110

避免浮光掠影，对于知识似是而非！

看了处理器的发展过程终于理解为什么32位的处理器是x86，而64位的处理器是x86-64，从64位的体系结构是IA32（即32位处理器）的64位扩展，同指令集上和体系架构上来说，就是在内存上进行了的扩展。而从公司的发展来看，64位处理器的指令集是由AMD与Intel交叉授权产生的，也可以理解为从属于一个产品系列。

旁注中的“摩尔定律”，1965年的预测，在10年内芯片上的晶体管数量每年翻一番。这种预测既“乐观”又“短视”。乐观是因为，晶体管的数量平均每18个月翻一番，而短视是因为，这种翻倍增长持续了近50年。

硬件上的高速增长支撑了计算机工业的发展，也是硬件的发展，支撑了深度学习等算法能够从理论走向实践。这一角度是以前没有特别重视的。

程序编码的简单过程：

```shell
$ gcc -Og -o p p1.c p2.c
```
其中 `gcc` 为Linux系统默认的编译器，`-Og` 表示编译器的优化级别，`-Og`生成的是符合原始C代码整体结构的机器代码的优化等级。更高的优化等级为`-O1` `-O2`,产生的机器代码优化后可能会与原始的C代码关系难以理解。

- 在编译的过程中，首先编译器通过C预处理器扩展源码，将`#include`部分的内容展开（插入`#include`的内容）
- 宏展开，将所有`#define`的内容进行声明和替换
- **编译器**产生两个源文件的汇编代码：`p1.s`和`p2.s`
- **汇编器**将汇编代码转化为二进制目标文件`p1.o`和`p2.o`，目标代码是机器代码的一种形式，包含指令的二进制表示
- **链接器**将目标代码文件和实现库函数的代码合并，产生最终 **可执行文件**p。可执行文件是处理器执行的代码格式

计算机利用了不同形式的抽象，这些层的抽象可以更利于使用，并隐藏细节。
在底层的抽象上主要有两种：

- ISA，CPU的指令集架构定义的机器级程序的格式和行为。
- 对于内存地址的抽象，提供给进程的虚拟内存看起来像一个连续的、大的字节数组。但是实际上由存储系统实现了将多个硬件存储器和操作系统软件结合起来。

产生汇编代码：

```shell
gcc -Og -S xxx.c
```

产生目标文件

```shell
gcc -Og -c xxx.c
```

将目标文件反汇编：

```shell
> objdum -d xxx.o
```

产生可执行文件：

```shell
> gcc -Og -o prog xxx.c xxx.c
```

其中会进行程序的链接，必会要有一个 *main* 程序。

